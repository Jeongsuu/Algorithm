# Dynamic Programming
---

### DP, 동적계획법이란?
---

큰 문제를 작은 문제로 나누어 접근하는 방식의 문제를 일컫는 용어이다.

어떠한 문제를 나누어 접근한다는 시각에서는 `분할정복(Divide and Conquer)` 와 컨셉이 비슷하다.

하지만 나누어 **접근하는 작은 문제가 중복해서 일어나는가에 대한 여부**에 차이가 존재한다.

분할정복은 작은 문제에서 반복이 일어나지 않는다. 반면 **DP는 작은 부분의 문제들이 반복되는 컨셉**을 이용해 문제를 풀어나가는 방법이다.

<br>

### Memoization
---

- 반복적으로 계산되는 것들의 계산 횟수를 줄이기 위해 이전에 계산했던 값을 저장해두었다가 다시 사용하는 방법으로 동적계획법에 핵심이 되는 기술이다.

`Memoization`은 **동적 프로그래밍 방식이 작은 문제들이 반복되고 이 작은 문제들의 결과값은 항상 같다** 라는 컨셉을 이용하여 한번 계산한 작은 문제의 결과를 저장해놓고 이를 다시 사용하는것을 의미한다.

간단한 예시로는 피보나치 수열이 있다.

피보나치 수열은 1, 1, 2, 3, 5, 8, 13 ... 의 수열을 이룬다.

`다음 수열 = 이전 수열 + 이전의 이전 수열` 이라는 점화식으로 이루어진 수열을 의미한다.

이를 `recursion` 방식으로 풀게되면 훨씬 간단히 풀 수 있으나 `fibo(n)` 함수에서 전달된 `n`의 값이 증가함에 따라 호출되는 함수의 수가 기하급수적으로 증가하기 때문에 일정 수 이상의 순열을 구하기 힘들다.

이러한 경우, 동적계획법의 두가지 조건을 상기해보면 이를 쉽게 풀어낼 수 있다.

**1. 작은 문제들이 반복된다.**

-   `fibo(5)`를 구하기 위해서는 `fibo(4)`와 `fibo(3)`이 필요하며, 다시 `fibo(4)`를 구하기 위해서는 `fibo(3)`과 `fibo(2)`가 필요하다.

위 예시만 살펴봐도 `fibo(3)` 작업이 중복되는 것을 알 수 있다. **즉, 작은 문제들이 반복되는 구조이다.**

**2. 같은 작은 문제들의 결과값은 같다.**

-   피보나치 수열의 경우, 첫번째 수열값과 두번째 수열값은 1로 고정되어 있다. 이 말은 즉 3번째 수열 또한 항상 결과값이 2로 고정된다는 의미이다.

따라서, 모든 수열의 결과값은 항상 정답이 동일하다는 사실을 알 수 있다.

재귀를 이용한 피보나치 코드를 살펴본다.

```python

def fibo(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibo(n-1) + fibo(n-2)
```

DP 문제들은 재귀를 이용해서도 풀어낼 수 있으나, 대부분의 문제들을 시간초과 에러가 뜬다.

이러한 경우, 메모이제이션을 이용하여 DP방법으로 풀어내야 한다.


<br>

### 요약
---

1. 동적계획법이란, 큰 문제를 작은 문제들로 분할하여 해결해 나아가는 방식을 의미하며 작은 문제들의 답은 항상 동일하다.

2. **메모이제이션** 개념을 이용하여 이미 계산한 결과값을 저장하여 나중에 필요할 경우 저장된 값을 단순히 가져오기만 하면 된다는 부분에서 분할 정복과 차이가 존재한다.

3. DP = recursion + Memoization


<br>
<br>

내용 추가

---

## 다이나믹 프로그래밍

- 다이나믹 프로그래밍은 **메모리를 적절히 사용하여 수행 시간을 비약적으로 증가시키는 방법**
- **이미 게산된 결과(작은 문제)는 별도의 메모리 영역에 저장**하여 다시 게산하지 않도록 한다. -> 이게 핵심!
- 다이나믹 프로그래밍 구현은 일반적으로 탑다운 & 바텀업 방식으로 구성된다.

### 다이나믹 프로그래밍의 조건

- 최적 부분 구조
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.

- 중복되는 부분 문제
  - 동일한 작은 문제를 반복적으로 해결해야 한다.

### 메모이제이션

- 메모이제이션은 DP를 구현하는 방법 중 하나다.
- **한 번 게산한 결과를 메모리 공간에 메모**해놓는 기법.
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
  - 값을 기록해 놓는단느 점에서 **캐싱** 이라고도 한다.
  - **이를 통해 한 번 계산한걸 다시 계산해야 할 때는 계산없이 해당 결과값만 바로 가져와서 사용하여 빠른 속도로 문제를 풀어낼 수 있음.**

### 탑다운 vs 바텀업

- 탑다운(메모이제이션) 방식은 하향식이라고도 하며, 바텀업 방식은 상향식이라고도 한다.
- DP의 전형적인 형태는 바텀업 방식이다.
  - 결과 저장용 리스트를 DP 테이블이라고 부른다.
- 엄밀히 말하면 **메모이제이션**은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미한다.

재귀를 이용한 피보나치 수열 방식

```python
def fibo(x):
    if x == 1 or x == 2 :
        return 1
    return fibo(x-1) + fibo(x-2)
```

탑다운 방식(메모이제이션)

```python
# 한 번 계산한 결과를 기록, 메모이제이션 DP 테이블 초기화
dp = [0] * 100

# 피보나치를 재귀함수로 구현 (탑다운 DP)
def fibo(x):
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if dp[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식을 통해 피보나치 결과 반환
    dp[x] = fibo(x-1) + fibo(x-2)
    return dp[x]
```

바텀업 방식

```python
# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
dp = [0] * 100

# 1,2 번째 피보나치 수 초기화
dp[1] = 1
dp[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현 (바텀업 DP)
for i in range(3, n+1):
    dp[i] = dp[i-1] + dp[i-2]
```

바텀업 방식은 앞에서 부터 채워 나가면서 진행되는 방식.

바텀업 방식은 재귀함수를 쓰지 않고 앞에서부터 차곡차곡 점화식에 맞게 최적의 값을 DP 테이블에 담는 방식을 의미한다.


<br>

핵심 정리

- DP는 한번 계산한 결과를 특정 메모리에 기록하여 해당 결과를 이용하여 빠르게 정답을 얻어내는 방식. -> 메모이제이션!
- DP 구성방식은 탑다운 & 바텀업 크게 두 가지로 나뉜다.
  - 탑다운 : 가장 큰 문제를 방문 후 작은 문제를 호출하여 답을 찾는 방식.
  - 바텀업 : 가장 작은 문제들부터 답을 구해가며 전체 문제의 답을 찾는 방식.

탑다운 방식은 점화식을 이해하기 쉽다는 장점이 있고, 바텀업 방식은 재귀를 이용하지 않기 때문에 메모리 사용량을 줄일 수 있다는 장점이 있다.

