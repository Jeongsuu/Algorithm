# 2309 - 일곱 난쟁이

<br>

### 문제
---
왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.

아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.

아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.

### 입력
---
아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.

### 출력
---
일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.

### 제출 코드
---

```python
from sys import stdin

arr = [int(stdin.readline().strip()) for _ in range(9)]
arr.sort()
total = sum(arr)

for i in range(len(arr)):
    for j in range(i+1, len(arr)):
        if (total - arr[i] - arr[j]) == 100:
            for k in range(len(arr)):
                if k != i and k != j:
                    print(arr[k])
            exit()

```

### 코드 설명
---

위 문제는 모든 경우의 수를 탐색하는 브루트포스 방법을 통해 풀어냈다.

전달받은 배열의 길이는 9로 정해져 있었으며 우리가 원하는 배열의 길이는 7인것을 알고있었다. 

따라서 이중 `for`문을 통해 2개의 원소를 배제했을때에 대한 모든 경우의 수를 찾아낼 수 있다.

이중 `for`문을 이용해 각각의 `for`문에서 배제한 원소를 제외한 나머지 원소들의 합이 100인 경우, 해당 원소들을 출력하고 프로그램을 종료하도록 코드를 작성하였다.

<br>

### 다른 사람의 풀이
---

대부분의 풀이가 필자의 코드와 같이 이중 포문을 이용하여 문제를 풀었으나 `itertools`의 조합을 이용하여 문제를 푼 해설도 있었다.

코드는 아래와 같다.

```python

from itertools import combinations

a = [int(input() for i in range(9)]
p = list(combinations(a, 7))                # a배열에서 7개의 원소를 조합하여 만들수 있는 모든 결과들을 리스트에 담는다.
for i in p:
    if sum(i) == 100:
        print(*sorted(i, sep='\n')
        break
```

매우 직관적이다, 전달받은 인자 9개 중 7개의 조합으로 만들어 낼 수 있는 모든 경우의 수를 조합하여 리스트에 담는다.

이후 리스트 원소들을 순회하며 원소의 `sum`이 100인 경우를 찾아내면 `unpacking`과 `sep`를 이용해 한 줄의 코드로 출력 포맷에 맞춰 출력한다.

여기서 `sep`은 구분자를 의미하며 이는 각각의 원소를 출력할떄 원소들을 구분하고자 할 때 사용하는 옵션이다.

`sep`은 앞으로 아주 유용하게 사용할 수 있을것 같다.

