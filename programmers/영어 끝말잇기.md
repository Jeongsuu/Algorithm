# Programmers - 영어 끝말잇기

### 문제 설명
---
1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.

1. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
2. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
3. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
4. 이전에 등장했던 단어는 사용할 수 없습니다.
5. 한 글자인 단어는 인정되지 않습니다.
다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.

tank → kick → know → wheel → land → dream → mother → robot → tank

위 끝말잇기는 다음과 같이 진행됩니다.

- 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.
- 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.
- 3번 사람이 자신의 첫 번째 차례에 know를 말합니다.
- 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.
- (계속 진행)

끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.

사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.

### 제한 사항
- 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.
- words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.
- 단어의 길이는 2 이상 50 이하입니다.
- 모든 단어는 알파벳 소문자로만 이루어져 있습니다.
- 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.
- 정답은 [ 번호, 차례 ] 형태로 return 해주세요.
- 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.

<br>

### 제출 코드
---
```python
def solution(n, words):
    person_idx = 0
    duple_check = []
    turn_cnt = 1
    words = words[::-1]
    before_word = str(words[-1][0])

    while words:
        
        person_idx += 1
        if person_idx > n:
            person_idx %= n
            turn_cnt += 1

        tmp = words.pop()
        if tmp in duple_check or before_word != tmp[0]:
            return [person_idx, turn_cnt]
        else:
            duple_check.append(tmp)
            before_word = str(tmp[-1])

    return [0,0]
```

<br>

### 문제풀이
---

위 문제에 정답을 작성하기 위해 신경써서 확인해야 할 부분은 2가지이다.

> 1. 현재 언급한 단어가 기존에 언급했던 단어인가?
> 2. 현재 언급한 단어가 직전에 언급한 단어와 끝말잇기가 이어지는가?

두 부분에 대해서만 검증을 진행하면 된다.

이를 위해 단어의 중복 체크를 위해 `duple_check` 라는 리스트 타입의 변수를 이용해 확인하고, 끝말잇기가 이어지는지 체크하기 위해 `before_word` 라는 변수를 활용하였다.

또한 출력 결과는 `[번호, 차례]` 포맷이므로 두 정보를 알 수 있는 변수가 필요하다.

따라서, 위 두 변수를 각각 `person_idx`, `turn_cnt` 라는 변수를 생성하여 이에대한 정보를 저장하였다.

전달받은 배열 `words`를 순차적으로 각각 순회하며 앞서 언급한 정답을 위한 출력 2가지 조건(중복여부, 끝말잇기가 이어지지 않는 경우)을 확인하며 만일 조건에 적합할 경우 정답 포맷에 맞춰 값을 출력한다.

만일 두 조건에서 필터링이 되지 않을 경우, `duple_check` 배열에 이를 추가하고, `before_word` 변수의 값을 재정의한다.

이를 반복하며 모든 문자의 순회가 정상적으로 끝난 경우에는 `[0,0]` 을 반환한다.

<br>

### 다른 사람의 풀이
---
```python
def solution(n, words):
    for p in range(1, len(words)):
        if words[p][0] != words[p-1][-1] or words[p] in words[:p]:
            return [(p%n)+1, (p//n)+1]
        else:
            return [0,0]
```

~~깔쌈하다..~~

`words` 배열을 순회하며 현재 단어의 첫번쨰 스펠링이 직전 단어의 마지막 스펠링과 동일한지, `words`배열에서 현재 단어의 위치 기준으로 이전에 동일한 값이 있었는지 슬라이싱을 통해 확인하였다.

또한, 일부로 `idx` 순회를 1번부터 진행하여 `words[p][0] != words[p-1][-1]` 조건에서 발생할 수 있는 예외를 유연하게 대처하였다.

진짜 깔끔한 코드다!