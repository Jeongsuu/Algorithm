# 타겟 넘버

### 문제 설명
---
n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

```
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
```

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

### 제한사항
---
- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

<br>

### 제출코드
---
```python

def solution(numbers, target):
    tree = [0]
    for num in numbers:
        sub_tree = []
        for tree_num in tree:
            sub_tree.append(tree_num + num)
            sub_tree.append(tree_num - num)
        tree = sub_tree
    return tree.count(target)
```

<br>

### 문제풀이
---

문제는 간단했으나 단번에 풀어내지는 못했습니다.

처음에는 DP를 이용하려 접근했으나 다른 분들의 풀이를 보고 `Tree` 구조를 형상화하여 문제를 풀어내는 방법을 보고 해당 방법으로 접근하여 풀었습니다.

문제를 풀어내기 위해서 `Tree` 구조를 이용했으며 해당 Tree의 각 `level` 에 따라 덧셈, 뺄셈 연산을 진행하며 `sub_tree`를 구성해내는 방식입니다.

예를 들어, `numbers` 배열이 `[1, 2, 3]` 으로 주어진다면 

`tree = [0]` 트리를 시작으로 첫 번째 원소의 값을 더하고 뺍니다.

그러면 트리는 `[0]` 에서 `[1, -1]` 이 됩니다.

이후 `numbers` 의 두 번째 원소를 `tree` 배열을 순회하며 각각 덧셈, 뺄셈 연산을 진행합니다.

그러면 트리는 `[1, -1]` 에서 `[3, 1, -1, -3]` 이 됩니다.

이후 똑같은 연산을 진행하면 `[6, 4, 0, 0, -2, 2, -4, -6]` 이 됩니다.

두 개의 반복문이 필요하며 한 번의 반복문이 진행될 때 마다 `tree` 배열의 길이는 2배씩 증가하게 됩니다.

`numbers` 배열을 모두 순회하며 연산이 끝나면 결과 배열에서 `target`의 갯수를 반환합니다.

